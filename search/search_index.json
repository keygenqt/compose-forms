{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Compose Forms Field state manager and basic set of validation, fields Connection repositories { maven(\"https://artifactory.keygenqt.com/artifactory/open-source\") } dependencies { implementation(\"com.keygenqt.forms:compose-forms:{version}\") } Features State TextField Validation Systematization License Copyright 2022 Vitaliy Zarubin Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#compose-forms","text":"Field state manager and basic set of validation, fields","title":"Compose Forms"},{"location":"#connection","text":"repositories { maven(\"https://artifactory.keygenqt.com/artifactory/open-source\") } dependencies { implementation(\"com.keygenqt.forms:compose-forms:{version}\") }","title":"Connection"},{"location":"#features","text":"State TextField Validation Systematization","title":"Features"},{"location":"#license","text":"Copyright 2022 Vitaliy Zarubin Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"stateTextField/","text":"The library calls for encapsulating state management FormFieldState Default text Savable text Check has errors Validate Clear errors Position to end Usage val fieldState: FormFieldState = remember { FormFieldState() } TextField( value = fieldState.text, onValueChange = { fieldState.text = it }, label = { Text(\"Label\") }, modifier = modifier .fillMaxWidth() .onFocusChanged { focusState -> if (focusState.isFocused) { fieldState.positionToEnd() } }, isError = fieldState.hasErrors, )","title":"State TextField"},{"location":"stateTextField/#formfieldstate","text":"Default text Savable text Check has errors Validate Clear errors Position to end","title":"FormFieldState"},{"location":"stateTextField/#usage","text":"val fieldState: FormFieldState = remember { FormFieldState() } TextField( value = fieldState.text, onValueChange = { fieldState.text = it }, label = { Text(\"Label\") }, modifier = modifier .fillMaxWidth() .onFocusChanged { focusState -> if (focusState.isFocused) { fieldState.positionToEnd() } }, isError = fieldState.hasErrors, )","title":"Usage"},{"location":"systematizationTextField/","text":"You can group fields into a form. You can make fields both custom and use ready-made Fields form Default fields form FormField FormFieldEmail FormFieldPassword FormFieldPhone FormFieldNumber FormField numbers Numeric fields (FormFieldPhone, FormFieldNumber) have the parameter mask. Examples of mask: +380 (###) ###-##-## +7 (###) ###-##-## +# (###) ###-##-## ####-####-####-#### Params /** * Default form field * * @param modifier modifier to apply to this layout node. * @param enabled controls the enabled state of the [TextField]. * @param readOnly controls the editable state of the [TextField]. * @param label the optional label to be displayed. * @param textStyle Styling configuration for a Text. * @param imeAction Signals the keyboard what type of action should be displayed. It is not guaranteed if the keyboard will show the requested action. * @param visualTransformation * @param keyboardActions The KeyboardActions class allows developers to specify actions that will be triggered in response to users triggering IME action on the software keyboard. * @param leadingIcon the optional leading icon to be displayed at the beginning of the text field container * @param trailingIcon the optional trailing icon to be displayed at the end of the text field container * @param colors TextFieldColors for settings colors * @param state remember with FormFieldState for management TextField. * @param onValueChange the callback that is triggered when the input service updates values in [TextFieldValue]. * @param lines height in lines. * @param maxLines the maximum height in terms of maximum number of visible lines. * @param singleLine field becomes a single horizontally scrolling text field instead of wrapping onto multiple lines. * @param maxLength Maximum allowed field length. * @param mask +380 (###) ###-##-##, +7 (###) ###-##-##, +# (###) ###-##-##, ####-####-####-#### etc * @param placeholder the optional placeholder to be displayed when the text field is in focus and the input text is empty * @param keyboardType keyboard type used to request an IME. * @param contentError the optional error to be displayed inside the text field container. */ @OptIn(ExperimentalComposeUiApi::class, ExperimentalFoundationApi::class) @Composable fun FormField( modifier: Modifier = Modifier, enabled: Boolean = true, readOnly: Boolean = false, label: String? = null, textStyle: TextStyle = LocalTextStyle.current, imeAction: ImeAction = ImeAction.Next, visualTransformation: VisualTransformation = VisualTransformation.None, keyboardActions: KeyboardActions = KeyboardActions(), leadingIcon: @Composable (() -> Unit)? = null, trailingIcon: @Composable (() -> Unit)? = null, colors: TextFieldColors = TextFieldDefaults.textFieldColors(), state: FormFieldState = remember { FormFieldState() }, onValueChange: ((TextFieldValue) -> TextFieldValue)? = null, lines: Int? = null, maxLines: Int = 1, singleLine: Boolean = true, maxLength: Int? = null, mask: String? = null, placeholder: String? = null, keyboardType: KeyboardType = KeyboardType.Text, contentError: @Composable (() -> Unit)? = null, ) Usage with form -> @see <- // Create form enum class SignInFieldsForm(val state: FormFieldState) : FormStates { SignInEmail(EmailStateValidateRequired()), SignInPassword(PasswordStateValidateRequired()), } Example composable form -> @see <- @OptIn(ExperimentalComposeUiApi::class) @Composable fun SignInForm( loading: Boolean = false, onNavigationEvent: (SignInEvents) -> Unit = {}, ) { val softwareKeyboardController = LocalSoftwareKeyboardController.current val localFocusManager = LocalFocusManager.current val scope = rememberCoroutineScope() val padding = 16.dp // create from state val formFields = FormFieldsState().apply { add(SignInEmail, remember { SignInEmail.state.default(ConstantsApp.DEBUG_CREDENTIAL_LOGIN) }) add(SignInPassword, remember { SignInPassword.state.default(ConstantsApp.DEBUG_CREDENTIAL_PASSW) }) } // for focus to field val requesterFieldEmail = remember { FocusRequester() } val requesterFieldPassword = remember { FocusRequester() } // click submit val submitClick = { // validate before send formFields.validate() // check has errors if (!formFields.hasErrors()) { // submit query onNavigationEvent( SignInEvents.SignIn( login = formFields.get(SignInEmail).getValue(), passw = formFields.get(SignInPassword).getValue(), ) ) // hide keyboard localFocusManager.clearFocus() softwareKeyboardController?.hide() } } // create field email FormFieldEmail( modifier = Modifier.focusRequester(requesterFieldEmail), label = stringResource(id = R.string.form_email), enabled = !loading, state = formFields.get(SignInEmail), imeAction = ImeAction.Next, colors = customTextFieldColors(), keyboardActions = KeyboardActions(onNext = { requesterFieldPassword.requestFocus() }) ) Spacer(modifier = Modifier.size(padding)) // create field password FormFieldPassword( modifier = Modifier.focusRequester(requesterFieldPassword), enabled = !loading, state = formFields.get(SignInPassword), imeAction = ImeAction.Done, colors = customTextFieldColors(), tintIcon = MaterialTheme.colors.onPrimary, keyboardActions = KeyboardActions(onDone = { submitClick.invoke() }) ) Spacer(modifier = Modifier.size(padding)) // submit button Button( enabled = !loading, onClick = { submitClick.invoke() }, modifier = Modifier.fillMaxWidth(), shape = MaterialTheme.shapes.large, colors = ButtonDefaults.textButtonColors(backgroundColor = MaterialTheme.colors.secondary), ) { Text( text = stringResource(id = R.string.form_button_submit).uppercase(), ) } // clear focus after end LaunchedEffect(Unit) { scope.launch { delay(10) requesterFieldEmail.requestFocus() } } } Preview","title":"Systematization"},{"location":"systematizationTextField/#fields-form","text":"Default fields form FormField FormFieldEmail FormFieldPassword FormFieldPhone FormFieldNumber","title":"Fields form"},{"location":"systematizationTextField/#formfield-numbers","text":"Numeric fields (FormFieldPhone, FormFieldNumber) have the parameter mask. Examples of mask: +380 (###) ###-##-## +7 (###) ###-##-## +# (###) ###-##-## ####-####-####-####","title":"FormField numbers"},{"location":"systematizationTextField/#params","text":"/** * Default form field * * @param modifier modifier to apply to this layout node. * @param enabled controls the enabled state of the [TextField]. * @param readOnly controls the editable state of the [TextField]. * @param label the optional label to be displayed. * @param textStyle Styling configuration for a Text. * @param imeAction Signals the keyboard what type of action should be displayed. It is not guaranteed if the keyboard will show the requested action. * @param visualTransformation * @param keyboardActions The KeyboardActions class allows developers to specify actions that will be triggered in response to users triggering IME action on the software keyboard. * @param leadingIcon the optional leading icon to be displayed at the beginning of the text field container * @param trailingIcon the optional trailing icon to be displayed at the end of the text field container * @param colors TextFieldColors for settings colors * @param state remember with FormFieldState for management TextField. * @param onValueChange the callback that is triggered when the input service updates values in [TextFieldValue]. * @param lines height in lines. * @param maxLines the maximum height in terms of maximum number of visible lines. * @param singleLine field becomes a single horizontally scrolling text field instead of wrapping onto multiple lines. * @param maxLength Maximum allowed field length. * @param mask +380 (###) ###-##-##, +7 (###) ###-##-##, +# (###) ###-##-##, ####-####-####-#### etc * @param placeholder the optional placeholder to be displayed when the text field is in focus and the input text is empty * @param keyboardType keyboard type used to request an IME. * @param contentError the optional error to be displayed inside the text field container. */ @OptIn(ExperimentalComposeUiApi::class, ExperimentalFoundationApi::class) @Composable fun FormField( modifier: Modifier = Modifier, enabled: Boolean = true, readOnly: Boolean = false, label: String? = null, textStyle: TextStyle = LocalTextStyle.current, imeAction: ImeAction = ImeAction.Next, visualTransformation: VisualTransformation = VisualTransformation.None, keyboardActions: KeyboardActions = KeyboardActions(), leadingIcon: @Composable (() -> Unit)? = null, trailingIcon: @Composable (() -> Unit)? = null, colors: TextFieldColors = TextFieldDefaults.textFieldColors(), state: FormFieldState = remember { FormFieldState() }, onValueChange: ((TextFieldValue) -> TextFieldValue)? = null, lines: Int? = null, maxLines: Int = 1, singleLine: Boolean = true, maxLength: Int? = null, mask: String? = null, placeholder: String? = null, keyboardType: KeyboardType = KeyboardType.Text, contentError: @Composable (() -> Unit)? = null, )","title":"Params"},{"location":"systematizationTextField/#usage-with-form","text":"-> @see <- // Create form enum class SignInFieldsForm(val state: FormFieldState) : FormStates { SignInEmail(EmailStateValidateRequired()), SignInPassword(PasswordStateValidateRequired()), }","title":"Usage with form"},{"location":"systematizationTextField/#example-composable-form","text":"-> @see <- @OptIn(ExperimentalComposeUiApi::class) @Composable fun SignInForm( loading: Boolean = false, onNavigationEvent: (SignInEvents) -> Unit = {}, ) { val softwareKeyboardController = LocalSoftwareKeyboardController.current val localFocusManager = LocalFocusManager.current val scope = rememberCoroutineScope() val padding = 16.dp // create from state val formFields = FormFieldsState().apply { add(SignInEmail, remember { SignInEmail.state.default(ConstantsApp.DEBUG_CREDENTIAL_LOGIN) }) add(SignInPassword, remember { SignInPassword.state.default(ConstantsApp.DEBUG_CREDENTIAL_PASSW) }) } // for focus to field val requesterFieldEmail = remember { FocusRequester() } val requesterFieldPassword = remember { FocusRequester() } // click submit val submitClick = { // validate before send formFields.validate() // check has errors if (!formFields.hasErrors()) { // submit query onNavigationEvent( SignInEvents.SignIn( login = formFields.get(SignInEmail).getValue(), passw = formFields.get(SignInPassword).getValue(), ) ) // hide keyboard localFocusManager.clearFocus() softwareKeyboardController?.hide() } } // create field email FormFieldEmail( modifier = Modifier.focusRequester(requesterFieldEmail), label = stringResource(id = R.string.form_email), enabled = !loading, state = formFields.get(SignInEmail), imeAction = ImeAction.Next, colors = customTextFieldColors(), keyboardActions = KeyboardActions(onNext = { requesterFieldPassword.requestFocus() }) ) Spacer(modifier = Modifier.size(padding)) // create field password FormFieldPassword( modifier = Modifier.focusRequester(requesterFieldPassword), enabled = !loading, state = formFields.get(SignInPassword), imeAction = ImeAction.Done, colors = customTextFieldColors(), tintIcon = MaterialTheme.colors.onPrimary, keyboardActions = KeyboardActions(onDone = { submitClick.invoke() }) ) Spacer(modifier = Modifier.size(padding)) // submit button Button( enabled = !loading, onClick = { submitClick.invoke() }, modifier = Modifier.fillMaxWidth(), shape = MaterialTheme.shapes.large, colors = ButtonDefaults.textButtonColors(backgroundColor = MaterialTheme.colors.secondary), ) { Text( text = stringResource(id = R.string.form_button_submit).uppercase(), ) } // clear focus after end LaunchedEffect(Unit) { scope.launch { delay(10) requesterFieldEmail.requestFocus() } } }","title":"Example composable form"},{"location":"systematizationTextField/#preview","text":"","title":"Preview"},{"location":"validationTextField/","text":"You can make validate state both custom and use ready-made Ready-made states DomainStateValidate DomainStateValidateRequired EmailStateValidate EmailStateValidateRequired PhoneStateValidate PhoneStateValidateRequired UrlStateValidate UrlStateValidateRequired Usage val fieldState: FormFieldState = remember { DomainStateValidate() } TextField( value = fieldState.text, onValueChange = { fieldState.text = it }, label = { Text(\"Label\") }, modifier = modifier .fillMaxWidth() .onFocusChanged { focusState -> if (focusState.isFocused) { fieldState.positionToEnd() } }, isError = fieldState.hasErrors, ) fieldState.getError(LocalContext.current)?.let { error -> TextFieldError(text = error) } Ready-made validations Default methods for validation getErrorIsBlank getErrorIsNotDomain getErrorIsNotEmail getErrorIsNotPhone getErrorIsNotUrl Usage class CustomStateValidate : FormFieldState(checkValid = { target: String -> listOfNotNull( getErrorIsBlank(target), getErrorIsNotDomain(target), getErrorIsNotEmail(target), getCustomErrorSize(target), ) }) private fun getCustomErrorSize(target: String) = when { target.length != 5 -> { it: Context -> it.getString(R.string.contact_change_common_code_error_validate, \"5\") } else -> null }","title":"Validation"},{"location":"validationTextField/#ready-made-states","text":"DomainStateValidate DomainStateValidateRequired EmailStateValidate EmailStateValidateRequired PhoneStateValidate PhoneStateValidateRequired UrlStateValidate UrlStateValidateRequired","title":"Ready-made states"},{"location":"validationTextField/#usage","text":"val fieldState: FormFieldState = remember { DomainStateValidate() } TextField( value = fieldState.text, onValueChange = { fieldState.text = it }, label = { Text(\"Label\") }, modifier = modifier .fillMaxWidth() .onFocusChanged { focusState -> if (focusState.isFocused) { fieldState.positionToEnd() } }, isError = fieldState.hasErrors, ) fieldState.getError(LocalContext.current)?.let { error -> TextFieldError(text = error) }","title":"Usage"},{"location":"validationTextField/#ready-made-validations","text":"Default methods for validation getErrorIsBlank getErrorIsNotDomain getErrorIsNotEmail getErrorIsNotPhone getErrorIsNotUrl","title":"Ready-made validations"},{"location":"validationTextField/#usage_1","text":"class CustomStateValidate : FormFieldState(checkValid = { target: String -> listOfNotNull( getErrorIsBlank(target), getErrorIsNotDomain(target), getErrorIsNotEmail(target), getCustomErrorSize(target), ) }) private fun getCustomErrorSize(target: String) = when { target.length != 5 -> { it: Context -> it.getString(R.string.contact_change_common_code_error_validate, \"5\") } else -> null }","title":"Usage"}]}